<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Scala Note | Liu Xianggen</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="work," />
  

  <meta name="description" content="java对于那种长度按需要变化的数组，Java有ArrayList，C++有vector。Scala中的等效数据结构为ArrayBuffer 随机数12scala.util.Random.nextInt()scala.util.Random.nextFloat() 语句控制break1234567import scala.util.control.Breaksval loop = new Bre">
<meta name="keywords" content="work">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala Note">
<meta property="og:url" content="http://www.liuxianggen.com/2016/09/01/technology/Scala-Note/index.html">
<meta property="og:site_name" content="Liu Xianggen">
<meta property="og:description" content="java对于那种长度按需要变化的数组，Java有ArrayList，C++有vector。Scala中的等效数据结构为ArrayBuffer 随机数12scala.util.Random.nextInt()scala.util.Random.nextFloat() 语句控制break1234567import scala.util.control.Breaksval loop = new Bre">
<meta property="og:image" content="http://images.51cto.com/files/uploadimg/20100126/171446820.jpg">
<meta property="og:updated_time" content="2017-07-07T06:34:36.881Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala Note">
<meta name="twitter:description" content="java对于那种长度按需要变化的数组，Java有ArrayList，C++有vector。Scala中的等效数据结构为ArrayBuffer 随机数12scala.util.Random.nextInt()scala.util.Random.nextFloat() 语句控制break1234567import scala.util.control.Breaksval loop = new Bre">
<meta name="twitter:image" content="http://images.51cto.com/files/uploadimg/20100126/171446820.jpg">

  

  
    <link rel="icon" href="/images/favicon.jpg">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  

  

  <% if (theme.baidu_analytics){ %>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fb0e88cc5bbe470f7877739f0bf6bc4c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<% } %>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fb0e88cc5bbe470f7877739f0bf6bc4c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java"><span class="toc-text">java</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#随机数"><span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#语句控制"><span class="toc-text">语句控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#break"><span class="toc-text">break</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#breeze"><span class="toc-text">breeze</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DenseVector"><span class="toc-text">DenseVector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成"><span class="toc-text">生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Type-Specialization-类型专用化"><span class="toc-text">Type Specialization(类型专用化)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#读取文件"><span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-循环带间隔"><span class="toc-text">for 循环带间隔</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ScalaCl"><span class="toc-text">ScalaCl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CLArray"><span class="toc-text">CLArray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error"><span class="toc-text">Error</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-technology/Scala-Note" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Scala Note</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.09.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>LiuXianggen</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p><img src="http://images.51cto.com/files/uploadimg/20100126/171446820.jpg" alt=""></p>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>对于那种长度按需要变化的数组，Java有ArrayList，C++有vector。Scala中的等效数据结构为ArrayBuffer</p>
<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala.util.Random.nextInt()</div><div class="line">scala.util.Random.nextFloat()</div></pre></td></tr></table></figure>
<h1 id="语句控制"><a href="#语句控制" class="headerlink" title="语句控制"></a>语句控制</h1><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span></div><div class="line"><span class="keyword">val</span> loop = <span class="keyword">new</span> <span class="type">Breaks</span></div><div class="line">    loop.breakable &#123;</div><div class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until sum.length) &#123;</div><div class="line">        <span class="keyword">if</span> (rand &lt;= sum(i)) &#123; res = i; loop.<span class="keyword">break</span>() &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="breeze"><a href="#breeze" class="headerlink" title="breeze"></a>breeze</h1><p>breeze-viz是git开源项目scalanlp/breeze的一部分，它能在java/scala语言环境绘制x-y点图，统计图，二维矩阵灰度图。breeze项目现在用途很广泛，Spark MLlib很多机器学习算法建立在breeze之上。breeze中最主要的是它的breeze数学库，包括向量、矩阵等基本数据结构，各种数学函数、分布，数学常用算法等等。</p>
<h2 id="DenseVector"><a href="#DenseVector" class="headerlink" title="DenseVector"></a>DenseVector</h2><p>基本结构</p>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> breeze.linalg._</div><div class="line"><span class="keyword">import</span> breeze.plot._ </div><div class="line"><span class="keyword">val</span> x = linspace(<span class="number">0.0</span>,<span class="number">1.0</span>) <span class="comment">//a denseVector</span></div><div class="line"><span class="keyword">val</span> xx = <span class="type">Array</span>(<span class="number">2</span>d,<span class="number">3</span>d,<span class="number">4</span>d,<span class="number">5</span>d,<span class="number">6</span>d) <span class="comment">//只能是Double,float/int不能转换</span></div><div class="line"><span class="comment">//def create[V](data: Array[V], offset（位移）: Int, stride(步长): Int, length（截取长度）: Int): DenseVector[V]</span></div><div class="line"><span class="keyword">val</span> xxx = <span class="type">DenseVector</span>.create(xx, <span class="number">0</span>, <span class="number">1</span>,<span class="number">4</span>) <span class="comment">//2,3,4,5</span></div></pre></td></tr></table></figure>
<h1 id="Type-Specialization-类型专用化"><a href="#Type-Specialization-类型专用化" class="headerlink" title="Type Specialization(类型专用化)"></a>Type Specialization(类型专用化)</h1><p>Scala 2.8新特性，就是在泛型类型前加上注解@specialized。一旦加上@specialized后，编译器除了生成普通的版本外，还会为每一个基本类型生成一个对应的版本。Scala的基本类型有Unit, Boolean, Byte, Short, Char, Int, Long, Float, Double九种，那么编译器就会生成九种不同的版本。当然，你还可以指定生成对应的版本。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Util_plot</span></span>[<span class="meta">@specialized</span>(<span class="type">Int</span>, <span class="type">Float</span>, <span class="type">Double</span>) <span class="type">V</span>](x: <span class="type">Array</span>[<span class="type">V</span>],y:<span class="type">Array</span>[<span class="type">V</span>])&#123;</div><div class="line">	  <span class="keyword">val</span> f = <span class="type">Figure</span>()</div><div class="line">	  <span class="keyword">val</span> p = f.subplot(<span class="number">0</span>)</div><div class="line">	  <span class="keyword">if</span>(x.length == y.length)&#123;</div><div class="line">	 	  <span class="keyword">val</span> ss = x.map(_.toString().toDouble)</div><div class="line">	 	  <span class="keyword">val</span> xa = <span class="type">DenseVector</span>.create(x.map(_.toString().toDouble),<span class="number">0</span>,<span class="number">1</span>,x.length)<span class="comment">//choose all</span></div><div class="line">		  <span class="keyword">val</span> ya = <span class="type">DenseVector</span>.create(y.map(_.toString().toDouble),<span class="number">0</span>,<span class="number">1</span>,y.length)<span class="comment">//choose all</span></div><div class="line">		  p     += plot(xa, ya)</div><div class="line">		  p.xlabel = <span class="string">"x axis"</span></div><div class="line">		  p.ylabel = <span class="string">"y axis"</span></div><div class="line">	  &#125;<span class="keyword">else</span>&#123;</div><div class="line">	 	  <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.<span class="type">VerifyError</span>(<span class="string">"the data for two axis dismatched!"</span>)</div><div class="line">	  &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>查找最大值下标： List(0, 43, 1, 34, 10).zipWithIndex.maxBy(_._1)._2</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></div><div class="line"><span class="keyword">val</span> source   = <span class="type">Source</span>.fromFile(<span class="string">"./data/best_qfunc"</span>)</div><div class="line"><span class="keyword">val</span> iterator = source.getLines()</div></pre></td></tr></table></figure>
<h2 id="for-循环带间隔"><a href="#for-循环带间隔" class="headerlink" title="for 循环带间隔"></a>for 循环带间隔</h2><p><code>for(i&lt;- 1000 until (spikeNum) by Math.round(1000/(rate*this.dt)).toInt){}</code></p>
<p>reduceLeft,reduceRight<br>reduceLeft: reduceLeft<a href="f: (B, A" target="_blank" rel="external">B &gt;: A</a> ⇒ B): B<br>reduceRight: reduceRight<a href="op: (A, B" target="_blank" rel="external">B &gt;: A</a> ⇒ B): B<br>reduceLeft从列表的左边往右边应用reduce函数，reduceRight从列表的右边往左边应用reduce函数<br>Example<br>val nums = List(2.0,2.0,3.0)<br>val resultLeftReduce = nums.reduceLeft(math.pow)  // = pow( pow(2.0,2.0) , 3.0) = 64.0<br>val resultRightReduce = nums.reduceRight(math.pow) // = pow(2.0, pow(2.0,3.0)) = 256.0<br>5.fold,foldLeft,foldRight<br>fold: fold<a href="z: A1" target="_blank" rel="external">A1 &gt;: A</a>(op: (A1, A1) ⇒ A1): A1 带有初始值的reduce,从一个初始值开始，从左向右将两个元素合并成一个，最终把列表合并成单一元素。<br>foldLeft: foldLeft<a href="z: B" target="_blank" rel="external">B</a>(f: (B, A) ⇒ B): B 带有初始值的reduceLeft<br>foldRight: foldRight<a href="z: B" target="_blank" rel="external">B</a>(op: (A, B) ⇒ B): B 带有初始值的reduceRight<br>val nums = List(2,3,4)<br>val sum = nums.fold(1)(<em>+</em>)  // = 1+2+3+4 = 9<br>val nums = List(2.0,3.0)<br>val result1 = nums.foldLeft(4.0)(math.pow) // = pow(pow(4.0,2.0),3.0) = 4096<br>val result2 = nums.foldRight(1.0)(math.pow) // = pow(1.0,pow(2.0,3.0)) = 8.0<br>6.sortBy,sortWith,sorted<br>sortBy: sortBy<a href="f: (A" target="_blank" rel="external">B</a> ⇒ B)(implicit ord: math.Ordering[B]): List[A] 按照应用函数f之后产生的元素进行排序<br>sorted： sorted<a href="implicit ord: math.Ordering[B]">B &gt;: A</a>: List[A] 按照元素自身进行排序<br>sortWith： sortWith(lt: (A, A) ⇒ Boolean): List[A] 使用自定义的比较函数进行排序<br>val nums = List(1,3,2,4)<br>val sorted = nums.sorted  //List(1,2,3,4)<br>val users = List((“HomeWay”,25),(“XSDYM”,23))<br>val sortedByAge = users.sortBy{case(user,age) =&gt; age}  //List((“XSDYM”,23),(“HomeWay”,25))<br>val sortedWith = users.sortWith{case(user1,user2) =&gt; user1._2 &lt; user2.<em>2} //List((“XSDYM”,23),(“HomeWay”,25))<br>7.filter, filterNot<br>filter: filter(p: (A) ⇒ Boolean): List[A]<br>filterNot: filterNot(p: (A) ⇒ Boolean): List[A]<br>filter 保留列表中符合条件p的列表元素 ， filterNot，保留列表中不符合条件p的列表元素<br>val nums = List(1,2,3,4)<br>val odd = nums.filter( </em> % 2 != 0) // List(1,3)<br>val even = nums.filterNot( _ % 2 != 0) // List(2,4)<br>8.count<br>count(p: (A) ⇒ Boolean): Int<br>计算列表中所有满足条件p的元素的个数，等价于 filter(p).length<br>val nums = List(-1,-2,0,1,2) val plusCnt1 = nums.count( &gt; 0) val plusCnt2 = nums.filter( &gt; 0).length </p>
<ol>
<li>diff, union, intersect</li>
</ol>
<p>diff:diff(that: collection.Seq[A]): List[A] 保存列表中那些不在另外一个列表中的元素，即从集合中减去与另外一个集合的交集</p>
<p>union : union(that: collection.Seq[A]): List[A] 与另外一个列表进行连结</p>
<p>intersect: intersect(that: collection.Seq[A]): List[A] 与另外一个集合的交集</p>
<p>val nums1 = List(1,2,3)<br>val nums2 = List(2,3,4)<br>val diff1 = nums1 diff nums2   // List(1)<br>val diff2 = nums2.diff(num1)   // List(4)<br>val union1 = nums1 union nums2  // List(1,2,3,2,3,4)<br>val union2 = nums2 ++ nums1        // List(2,3,4,1,2,3)<br>val intersection = nums1 intersect nums2  //List(2,3)<br>10.distinct<br>distinct: List[A] 保留列表中非重复的元素，相同的元素只会被保留一次<br>val list = List(“A”,”B”,”C”,”A”,”B”) val distincted = list.distinct // List(“A”,”B”,”C”)<br>1<br>11.groupBy, grouped</p>
<p>groupBy : groupBy<a href="f: (A" target="_blank" rel="external">K</a> ⇒ K): Map[K, List[A]] 将列表进行分组，分组的依据是应用f在元素上后产生的新元素<br>grouped: grouped(size: Int): Iterator[List[A]] 按列表按照固定的大小进行分组</p>
<p>val data = List((“HomeWay”,”Male”),(“XSDYM”,”Femail”),(“Mr.Wang”,”Male”))<br>val group1 = data.groupBy(_.<em>2) // = Map(“Male” -&gt; List((“HomeWay”,”Male”),(“Mr.Wang”,”Male”)),”Female” -&gt; List((“XSDYM”,”Femail”)))<br>val group2 = data.groupBy{case (name,sex) =&gt; sex} // = Map(“Male” -&gt; List((“HomeWay”,”Male”),(“Mr.Wang”,”Male”)),”Female” -&gt; List((“XSDYM”,”Femail”)))<br>val fixSizeGroup = data.grouped(2).toList // = Map(“Male” -&gt; List((“HomeWay”,”Male”),(“XSDYM”,”Femail”)),”Female” -&gt; List((“Mr.Wang”,”Male”)))<br>12.scan<br>scan<a href="z: B" target="_blank" rel="external">B &gt;: A, That</a>(op: (B, B) ⇒ B)(implicit cbf: CanBuildFrom[List[A], B, That]): That<br>由一个初始值开始，从左向右，进行积累的op操作，这个比较难解释，具体的看例子吧。<br>val nums = List(1,2,3)<br>val result = nums.scan(10)(</em>+_)   // List(10,10+1,10+1+2,10+1+2+3) = List(10,11,12,13)<br>13.scanLeft,scanRight<br>scanLeft: scanLeft<a href="z: B" target="_blank" rel="external">B, That</a>(op: (B, A) ⇒ B)(implicit bf: CanBuildFrom[List[A], B, That]): That</p>
<p>scanRight: scanRight<a href="z: B" target="_blank" rel="external">B, That</a>(op: (A, B) ⇒ B)(implicit bf: CanBuildFrom[List[A], B, That]): That</p>
<p>scanLeft: 从左向右进行scan函数的操作，scanRight：从右向左进行scan函数的操作</p>
<p>val nums = List(1.0,2.0,3.0)<br>val result = nums.scanLeft(2.0)(math.pow)   // List(2.0,pow(2.0,1.0), pow(pow(2.0,1.0),2.0),pow(pow(pow(2.0,1.0),2.0),3.0) = List(2.0,2.0,4.0,64.0)<br>val result = nums.scanRight(2.0)(math.pow)  // List(2.0,pow(3.0,2.0), pow(2.0,pow(3.0,2.0)), pow(1.0,pow(2.0,pow(3.0,2.0))) = List(1.0,512.0,9.0,2.0)<br>1<br>2<br>3<br>14.take,takeRight,takeWhile</p>
<p>take : takeRight(n: Int): List[A] 提取列表的前n个元素 takeRight: takeRight(n: Int): List[A] 提取列表的最后n个元素 takeWhile: takeWhile(p: (A) ⇒ Boolean): List[A] 从左向右提取列表的元素，直到条件p不成立</p>
<p>val nums = List(1,1,1,1,4,4,4,4)<br>val left = nums.take(4)   // List(1,1,1,1)<br>val right = nums.takeRight(4) // List(4,4,4,4)<br>val headNums = nums.takeWhile( _ == nums.head)  // List(1,1,1,1)<br>15.drop,dropRight,dropWhile<br>drop: drop(n: Int): List[A] 丢弃前n个元素，返回剩下的元素 dropRight: dropRight(n: Int): List[A] 丢弃最后n个元素，返回剩下的元素 dropWhile: dropWhile(p: (A) ⇒ Boolean): List[A] 从左向右丢弃元素，直到条件p不成立</p>
<p>val nums = List(1,1,1,1,4,4,4,4)<br>val left = nums.drop(4)   // List(4,4,4,4)<br>val right = nums.dropRight(4) // List(1,1,1,1)<br>val tailNums = nums.dropWhile( <em> == nums.head)  // List(4,4,4,4)<br>16.span, splitAt, partition<br>span : span(p: (A) ⇒ Boolean): (List[A], List[A]) 从左向右应用条件p进行判断，直到条件p不成立，此时将列表分为两个列表<br>splitAt: splitAt(n: Int): (List[A], List[A]) 将列表分为前n个，与，剩下的部分<br>partition: partition(p: (A) ⇒ Boolean): (List[A], List[A]) 将列表分为两部分，第一部分为满足条件p的元素，第二部分为不满足条件p的元素<br>val nums = List(1,1,1,2,3,2,1)<br>val (prefix,suffix) = nums.span( </em> == 1) // prefix = List(1,1,1), suffix = List(2,3,2,1)<br>val (prefix,suffix) = nums.splitAt(3)  // prefix = List(1,1,1), suffix = List(2,3,2,1)<br>val (prefix,suffix) = nums.partition( _ == 1) // prefix = List(1,1,1,1), suffix = List(2,3,2)<br>17.padTo<br>padTo(len: Int, elem: A): List[A]</p>
<p>将列表扩展到指定长度，长度不够的时候，使用elem进行填充，否则不做任何操作。</p>
<p> val nums = List(1,1,1)<br> val padded = nums.padTo(6,2)   // List(1,1,1,2,2,2)<br>1<br>2<br>18.combinations,permutations</p>
<p>combinations: combinations(n: Int): Iterator[List[A]] 取列表中的n个元素进行组合，返回不重复的组合列表，结果一个迭代器</p>
<p>permutations: permutations: Iterator[List[A]] 对列表中的元素进行排列，返回不重得的排列列表，结果是一个迭代器</p>
<p>val nums = List(1,1,3)<br>val combinations = nums.combinations(2).toList //List(List(1,1),List(1,3))<br>val permutations = nums.permutations.toList        // List(List(1,1,3),List(1,3,1),List(3,1,1))<br>1<br>2<br>3<br>19.zip, zipAll, zipWithIndex, unzip,unzip3</p>
<p>zip: zip<a href="that: GenIterable[B]" target="_blank" rel="external">B</a>: List[(A, B)] 与另外一个列表进行拉链操作，将对应位置的元素组成一个pair，返回的列表长度为两个列表中短的那个</p>
<p>zipAll: zipAll<a href="that: collection.Iterable[B], thisElem: A, thatElem: B" target="_blank" rel="external">B</a>: List[(A, B)] 与另外一个列表进行拉链操作，将对应位置的元素组成一个pair，若列表长度不一致，自身列表比较短的话使用thisElem进行填充，对方列表较短的话使用thatElem进行填充</p>
<p>zipWithIndex：zipWithIndex: List[(A, Int)] 将列表元素与其索引进行拉链操作，组成一个pair</p>
<p>unzip: unzip<a href="implicit asPair: (A">A1, A2</a> ⇒ (A1, A2)): (List[A1], List[A2]) 解开拉链操作</p>
<p>unzip3: unzip3<a href="implicit asTriple: (A">A1, A2, A3</a> ⇒ (A1, A2, A3)): (List[A1], List[A2], List[A3]) 3个元素的解拉链操作</p>
<p>val alphabet = List(“A”,B”,”C”)<br>val nums = List(1,2)<br>val zipped = alphabet zip nums   // List((“A”,1),(“B”,2))<br>val zippedAll = alphabet.zipAll(nums,”*”,-1)   // List((“A”,1),(“B”,2),(“C”,-1))<br>val zippedIndex = alphabet.zipWithIndex  // List((“A”,0),(“B”,1),(“C”,3))<br>val (list1,list2) = zipped.unzip        // list1 = List(“A”,”B”), list2 = List(1,2)<br>val (l1,l2,l3) = List((1, “one”, ‘1’),(2, “two”, ‘2’),(3, “three”, ‘3’)).unzip3   // l1=List(1,2,3),l2=List(“one”,”two”,”three”),l3=List(‘1’,’2’,’3’)<br>20.slice</p>
<p>slice(from: Int, until: Int): List[A] 提取列表中从位置from到位置until(不含该位置)的元素列表</p>
<p>val nums = List(1,2,3,4,5)<br>val sliced = nums.slice(2,4)  //List(3,4)</p>
<p>21.sliding</p>
<p>sliding(size: Int, step: Int): Iterator[List[A]] 将列表按照固定大小size进行分组，步进为step，step默认为1,返回结果为迭代器</p>
<p>val nums = List(1,1,2,2,3,3,4,4)<br>val groupStep2 = nums.sliding(2,2).toList  //List(List(1,1),List(2,2),List(3,3),List(4,4))<br>val groupStep1 = nums.sliding(2).toList //List(List(1,1),List(1,2),List(2,2),List(2,3),List(3,3),List(3,4),List(4,4))<br>22.updated<br>updated(index: Int, elem: A): List[A] 对列表中的某个元素进行更新操作<br>val nums = List(1,2,3,3)<br>val fixed = nums.updated(3,4)  // List(1,2,3,4)</p>
<h1 id="ScalaCl"><a href="#ScalaCl" class="headerlink" title="ScalaCl"></a>ScalaCl</h1><h2 id="CLArray"><a href="#CLArray" class="headerlink" title="CLArray"></a>CLArray</h2><p>toString<br>zip<br>foreach</p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p><code>cla.map(x =&gt; {x*coef}).toCLArray</code><br><code>scala error: Cannot capture externals symbols yet</code><br>后来用for循环改写通过了，呃呃。<br><a href="http://www.scala-lang.org/files/archive/" target="_blank" rel="external">download</a><br><a href="http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/" target="_blank" rel="external">http://nativelibs4java.sourceforge.net/maven/com/nativelibs4java/</a><br><a href="https://pablomendes.wordpress.com/2015/07/26/scala-using-gpus1/" target="_blank" rel="external">https://pablomendes.wordpress.com/2015/07/26/scala-using-gpus1/</a></p>
<p><a href="http://ochafik.com/p_207" target="_blank" rel="external">ScalaCL</a><br><a href="https://ochafik.com/p_471" target="_blank" rel="external">Run Scala code on your GPU with ScalaCL in 1 minute !</a></p>

    
  </div>
</article>

</div>


  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">挣点熬夜的咖啡钱</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/wechat_pay.jpg" alt="">
          </li>
        
          <li class="item">
            <img src="/images/alipay.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>




  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
